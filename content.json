{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://blog.garenfeather.cn"},"pages":[{"title":"About","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"about/index.html","permalink":"http://blog.garenfeather.cn/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"categories/index.html","permalink":"http://blog.garenfeather.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"tags/index.html","permalink":"http://blog.garenfeather.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2018-01-29T09:25:05.000Z","updated":"2018-01-29T09:25:56.680Z","comments":true,"path":"2018/01/29/test/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/29/test/","excerpt":"","text":"sequenceDiagram loop every day Alice->>John: Hello John, how are you? John-->>Alice: Great! end graph TD A[Christmas] -->|Get money| B(Go shopping) B --> C{Let me think} C -->|One| D[Laptop] C -->|Two| E[iPhone] C -->|Three| F[Car] graph TB subgraph one a1-->a2 end subgraph two b1-->b2 end subgraph three c1-->c2 end c1-->a2","categories":[],"tags":[]},{"title":"stackeditTest","slug":"stackedit","date":"2018-01-29T05:08:02.000Z","updated":"2018-01-29T05:14:17.076Z","comments":true,"path":"2018/01/29/stackedit/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/29/stackedit/","excerpt":"","text":"Welcome to StackEdit!Hey! I’m your first Markdown document in StackEdit[^stackedit]. Don’t delete me, I’m very helpful! I can be recovered anyway in the Utils tab of the Settings dialog. DocumentsStackEdit stores your documents in your browser, which means all your documents are automatically saved locally and are accessible offline! Note: StackEdit is accessible offline after the application has been loaded for the first time. Your local documents are not shared between different browsers or computers. Clearing your browser’s data may delete all your local documents! Make sure your documents are synchronized with Google Drive or Dropbox (check out the Synchronization section). Create a documentThe document panel is accessible using the button in the navigation bar. You can create a new document by clicking New document in the document panel. Switch to another documentAll your local documents are listed in the document panel. You can switch from one to another by clicking a document in the list or you can toggle documents using Ctrl+[ and Ctrl+]. Rename a documentYou can rename the current document by clicking the document title in the navigation bar. Delete a documentYou can delete the current document by clicking Delete document in the document panel. Export a documentYou can save the current document to a file by clicking Export to disk from the menu panel. Tip: Check out the Publish a document section for a description of the different output formats. SynchronizationStackEdit can be combined with Google Drive and Dropbox to have your documents saved in the Cloud. The synchronization mechanism takes care of uploading your modifications or downloading the latest version of your documents. Note: Full access to Google Drive or Dropbox is required to be able to import any document in StackEdit. Permission restrictions can be configured in the settings. Imported documents are downloaded in your browser and are not transmitted to a server. If you experience problems saving your documents on Google Drive, check and optionally disable browser extensions, such as Disconnect. Open a documentYou can open a document from Google Drive or the Dropbox by opening the Synchronize sub-menu and by clicking Open from…. Once opened, any modification in your document will be automatically synchronized with the file in your Google Drive / Dropbox account. Save a documentYou can save any document by opening the Synchronize sub-menu and by clicking Save on…. Even if your document is already synchronized with Google Drive or Dropbox, you can export it to a another location. StackEdit can synchronize one document with multiple locations and accounts. Synchronize a documentOnce your document is linked to a Google Drive or a Dropbox file, StackEdit will periodically (every 3 minutes) synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be detected. If you just have modified your document and you want to force the synchronization, click the button in the navigation bar. Note: The button is disabled when you have no document to synchronize. Manage document synchronizationSince one document can be synchronized with multiple locations, you can list and manage synchronized locations by clicking Manage synchronization in the Synchronize sub-menu. This will let you remove synchronization locations that are associated to your document. Note: If you delete the file from Google Drive or from Dropbox, the document will no longer be synchronized with that location. PublicationOnce you are happy with your document, you can publish it on different websites directly from StackEdit. As for now, StackEdit can publish on Blogger, Dropbox, Gist, GitHub, Google Drive, Tumblr, WordPress and on any SSH server. Publish a documentYou can publish your document by opening the Publish sub-menu and by choosing a website. In the dialog box, you can choose the publication format: Markdown, to publish the Markdown text on a website that can interpret it (GitHub for instance), HTML, to publish the document converted into HTML (on a blog for example), Template, to have a full control of the output. Note: The default template is a simple webpage wrapping your document in HTML format. You can customize it in the Advanced tab of the Settings dialog. Update a publicationAfter publishing, StackEdit will keep your document linked to that publication which makes it easy for you to update it. Once you have modified your document and you want to update your publication, click on the button in the navigation bar. Note: The button is disabled when your document has not been published yet. Manage document publicationSince one document can be published on multiple locations, you can list and manage publish locations by clicking Manage publication in the menu panel. This will let you remove publication locations that are associated to your document. Note: If the file has been removed from the website or the blog, the document will no longer be published on that location. Markdown ExtraStackEdit supports Markdown Extra, which extends Markdown syntax with some nice features. Tip: You can disable any Markdown Extra feature in the Extensions tab of the Settings dialog. Note: You can find more information about Markdown syntax here and Markdown Extra extension here. TablesMarkdown Extra has a special syntax for tables: Item Value Computer $1600 Phone $12 Pipe $1 You can specify column alignment with one or two colons: Item Value Qty Computer $1600 5 Phone $12 12 Pipe $1 234 Definition ListsMarkdown Extra has a special syntax for definition lists too: Term 1Term 2: Definition A: Definition B Term 3 : Definition C : Definition D &gt; part of definition D Fenced code blocksGitHub’s fenced code blocks are also supported with Highlight.js syntax highlighting: 12// Foovar bar = 0; Tip: To use Prettify instead of Highlight.js, just configure the Markdown Extra extension in the Settings dialog. Note: You can find more information: about Prettify syntax highlighting here, about Highlight.js syntax highlighting here. FootnotesYou can create footnotes like this[^footnote]. [^footnote]: Here is the text of the footnote. SmartyPantsSmartyPants converts ASCII punctuation characters into “smart” typographic punctuation HTML entities. For example: ASCII HTML Single backticks &#39;Isn&#39;t this fun?&#39; ‘Isn’t this fun?’ Quotes &quot;Isn&#39;t this fun?&quot; “Isn’t this fun?” Dashes -- is en-dash, --- is em-dash – is en-dash, — is em-dash Table of contentsYou can insert a table of contents using the marker [TOC]: [TOC] MathJaxYou can render LaTeX mathematical expressions using MathJax, as on math.stackexchange.com: The Gamma function satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ Tip: To make sure mathematical expressions are rendered properly on your website, include MathJax into your template: 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt; Note: You can find more information about LaTeX mathematical expressions here. UML diagramsYou can also render sequence diagrams like this: And flow charts like this: Note: You can find more information: about Sequence diagrams syntax here, about Flow charts syntax here. Support StackEdit [^stackedit]: StackEdit is a full-featured, open-source Markdown editor based on PageDown, the Markdown library used by Stack Overflow and the other Stack Exchange sites. st=>start: Start e=>end op=>operation: My Operation cond=>condition: Yes or No? st->op->cond cond(yes)->e cond(no)->op{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks!{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"test","slug":"test","permalink":"http://blog.garenfeather.cn/categories/test/"}],"tags":[{"name":"stackedit","slug":"stackedit","permalink":"http://blog.garenfeather.cn/tags/stackedit/"}]},{"title":"利用heroku实现免费的全平台科学上网","slug":"利用heroku实现免费的全平台科学上网","date":"2018-01-25T14:03:23.000Z","updated":"2018-01-25T14:56:34.722Z","comments":true,"path":"2018/01/25/利用heroku实现免费的全平台科学上网/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/25/利用heroku实现免费的全平台科学上网/","excerpt":"一、前言思路来源准备 一台连得上Google的服务器（测试用，可选） 这里用的是腾讯云买的CentOS 7.2，新加坡节点 一个heroku账号 heroku平台注册需要翻墙，但登录和部署均不需要 账号还有免费app余额 一台便宜且容易搞到手的国内服务器（可选） 仅作为中转服务器，不需要多平台共用可以不备 需要梯子服务的平台对应的客户端（Android、Win、Mac、Linux）","text":"一、前言思路来源准备 一台连得上Google的服务器（测试用，可选） 这里用的是腾讯云买的CentOS 7.2，新加坡节点 一个heroku账号 heroku平台注册需要翻墙，但登录和部署均不需要 账号还有免费app余额 一台便宜且容易搞到手的国内服务器（可选） 仅作为中转服务器，不需要多平台共用可以不备 需要梯子服务的平台对应的客户端（Android、Win、Mac、Linux） 内容较复杂，显示不全，完整内容请访问：https://www.zybuluo.com/RhineGaren/note/1031077","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"network","slug":"network","permalink":"http://blog.garenfeather.cn/tags/network/"},{"name":"heroku","slug":"heroku","permalink":"http://blog.garenfeather.cn/tags/heroku/"},{"name":"wall","slug":"wall","permalink":"http://blog.garenfeather.cn/tags/wall/"}]},{"title":"Docker添加iptables防火墙规则构建容器间通信","slug":"Docker添加iptables防火墙规则构建容器间通信","date":"2018-01-14T21:43:04.000Z","updated":"2018-01-16T14:37:47.210Z","comments":true,"path":"2018/01/15/Docker添加iptables防火墙规则构建容器间通信/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/15/Docker添加iptables防火墙规则构建容器间通信/","excerpt":"一、坑从何来最近正好看到解析Docker单主机网络的部分，提到通过link链接容器，于是深入思考了下link的机制，首先如果为容器添加一条链接会发生以下几件事： 描述目标容器的环境变量会被创建 链接的别名和对应目标容器的ip地址会被添加到DNS覆盖列表中 如果跨容器通信被禁止，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。 重点在于第三点，这里Docker添加的防火墙规则是允许两个容器通信到什么地步呢，大概有以下三种猜想：","text":"一、坑从何来最近正好看到解析Docker单主机网络的部分，提到通过link链接容器，于是深入思考了下link的机制，首先如果为容器添加一条链接会发生以下几件事： 描述目标容器的环境变量会被创建 链接的别名和对应目标容器的ip地址会被添加到DNS覆盖列表中 如果跨容器通信被禁止，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。 重点在于第三点，这里Docker添加的防火墙规则是允许两个容器通信到什么地步呢，大概有以下三种猜想： 两个容器间任意端口自由通信，应该不太可能，达到这种地步接近Joined容器共用同一个网络栈的级别了 容器任意端口都能连上目标容器EXPOSE的端口 容器只有指定的的进程（如pid唯一）、指定的端口号能够连上目标容器EXPOSE的端口，至于这个指定的进程和端口号猜测是在构建的时候指定好并添加到配置中去的？ 最初的猜想是3，因为如果是2的话，容器被非法入侵岂不是可以新开个进程随意连上数据库往外倒数据？（后来仔细想想，容器都被入侵了，跟权限被提到root了有啥区别……当然是为所欲为啊，不过当时没想清楚就是了）这明显不安全。 这里验证最直观可靠的方式还是看iptables的路由规则，开始实验。 二、在踩坑的边缘试探1.实验环境 Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-63-generic x86_64) Docker version 17.05.0-ce, build 89658be 2.iptables设置查看当前iptables设置： 1$ iptables -nL 以防万一大家可以先清洗一遍iptables，有配置的同学记得提前备份： 1$ iptables -F 清洗后： 12345678910Chain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy DROP)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destinationChain DOCKER (0 references)target prot opt source destinationChain DOCKER-ISOLATION (0 references)target prot opt source destination 3.icc、iptables选项与/etc/default/dockericc是跨容器通信开关，iptables则是Docker是否应用防火墙规则的开关，于是修改/etc/default/docker文件，禁止跨容器通信，要求Docker使用iptables规则： 1DOCKER_OPTS=&quot;--icc=false --iptables=true&quot; 同时去掉注释，并重启docker服务： 1$ service docker restart 再次查看当前iptables配置，可以看到docker和docker-isolation都被加入到了chain-forward项中： 1234567891011121314Chain FORWARD (policy DROP)target prot opt source destination DOCKER-ISOLATION all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 ctstate RELATED,ESTABLISHEDDOCKER all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 DROP all -- 0.0.0.0/0 0.0.0.0/0 Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:3306ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:3306Chain DOCKER-ISOLATION (1 references)target prot opt source destination RETURN all -- 0.0.0.0/0 0.0.0.0/0 此处用本机现有的mysql和redis做实验，redis依赖mysql（mysql密码请自行根据自己的配置修改）： 1$ docker run --rm --name mysql -e 3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 1$ docker run --rm --name redis --link mysql:mysql -d redis 操作完docker ps可以看到两个容器正常运行，但并没有看到iptables有新添加规则。 4.docker network之前的项目没有涉及到多网络配置，因此对network一无所知，加上无脑瞎找资料没思考清楚，误以为是两个容器不在一个网络内，于是查看默认bridge网络配置： 1$ docker network inspect bridge 部分相关配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;d14d164b2dbc43b33eb298d79e5928fda258129a02f6c2a7c310633a718d356c&quot;, &quot;Created&quot;: &quot;2018-01-15T03:53:42.133885625+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;Containers&quot;: &#123; &quot;5b81e33ddd5e7e79e6c315bd3889812362d19732e0ce9a0486edc98a26c59e77&quot;: &#123; &quot;Name&quot;: &quot;redis&quot;, &quot;EndpointID&quot;: &quot;df2e9dda0de35c4934a50d33bd23cb9d27301cac3882880ba58acf82713956f4&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;fada6a036ecba16bc1c08ec5b8fced59b51144a949d7c1051b78e88d7a4bb35f&quot;: &#123; &quot;Name&quot;: &quot;mysql&quot;, &quot;EndpointID&quot;: &quot;38a5036088b19daa08e212d947b44f3a94e823d9a2cd060d0fbfc19680591abf&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; &#125;, &quot;Labels&quot;: &#123;&#125;&#125; 发现两个容器都在默认网络里。顺便这里有个很迷的地方就是Options里的true和false都是字符串类型，但外面的却不是，后面会提到。观察配置发现icc选项还是true，说明刚才修改的/etc/default/docker文件很可能没起作用。此处有两个选择： 新建一个bridge网络，icc设为false 继续设法修改docker daemon启动选项 其实并没有选择，因为就参数来看只能设置icc，而iptables使用与否必须是docker daemon启动时设置好的。直接百度到的资料杂乱无章，对错参半，于是还是根据官网操作： 新建daemon.json： 1$ vim /etc/docker/daemon.json 输入以下内容 1234&#123; &quot;iptables&quot;: &quot;true&quot;, &quot;icc&quot;: &quot;false&quot;&#125; 并重启dockerd服务，发现会重启失败，显示： 1unable to configure the Docker daemon with file /etc/docker/daemon.json: json: cannot unmarshal string into Go value of type bool 这就是刚才提到的很迷的地方，欺负我们不懂go语言系列，参数改为以下内容： 1234&#123; &quot;iptables&quot;: true, &quot;icc&quot;: false&#125; 保存后再重启docker daemon，再次查看bridge网络，options选项中的com.docker.network.bridge.enable_icc应该为false了，说明配置生效了，此时再按上面步骤启动容器link，可以看到iptables多了两条规则： 1234Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:mysqlACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:mysql 操作成功，可以发现两个容器之间互联的是通过forward链的转发规则，具体规则可阅读iptables forward详解。外面替换一下两个容器的位置，也可以看到同样结果： 12$ docker run --rm --name redis -e 6379 -d redis$ docker run --rm --name mysql --link redis:redis -e MYSQL_ROOT_PASSWORD=123456 -d mysql 端口变成了redis的6379： 1234Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:6379ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:6379 5.结束验证过程中很多地方没想清楚胡乱操作一通，把原本简单的问题都搞复杂了，动手前深思熟虑还是很重要的啊（俗话说得好，真正写代码的时间能有20%不错了）。 二、后来1.仔细想想 其实当时还想顺着猜测3的思路深入思考过如果容器被非法入侵，直接攻击代码搞挂了原本的进程，用原本与目标容器3306连接的端口构建数据库的连接该怎么办……那当然是没办法啦啊哈哈哈，你说你家金库的钥匙密码人家都拿到了你的黄金怎么办，那当然是没办法的，重点应该在怎么防止密码和钥匙失窃上吧hhhhh。 而且退一步想，指定能与目标容器3306连接的端口可以办得到，但是绑定到进程上是没有实现的可能的，作为进程标识的pid是会被复用的，重启后pid会变，不可能每次重启进程都重新设定绑定关系，而且也没有设定的基础。 网络基础还是不扎实，很多东西没真正理解。 2.论如何查资料 珍爱生命，少查csdn，多看官方文档，过脑思考比无脑开车撞墙要好 努力改掉下意识避开英文的习惯 写操作指南不指明各种相关版本号的都是耍流氓 基础不牢，地动山摇，我还是太天真了.jpg","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.garenfeather.cn/tags/Docker/"},{"name":"network","slug":"network","permalink":"http://blog.garenfeather.cn/tags/network/"},{"name":"iptables","slug":"iptables","permalink":"http://blog.garenfeather.cn/tags/iptables/"}]},{"title":"【Philosophical Dilemmas】上帝、永生与信仰","slug":"【Philosophical-Dilemmas】上帝、永生与信仰","date":"2017-10-24T12:24:44.000Z","updated":"2018-01-24T06:37:42.886Z","comments":true,"path":"2017/10/24/【Philosophical-Dilemmas】上帝、永生与信仰/","link":"","permalink":"http://blog.garenfeather.cn/2017/10/24/【Philosophical-Dilemmas】上帝、永生与信仰/","excerpt":"前言：首先，这是《Philosophical Dilemmas》第三版中译本《没有标准答案的哲学问题》的读书笔记（阅读理解/课后习题/这次语文月考又挂了哎），全书共五章，每章约7个问题，回答包含两到三个立场，都是根本性的问题，难以回答，但还是试着做出选择并给出自己的理由，必然存在前后矛盾，尽力逻辑自洽。全部大概分成五次发，欢迎讨论，求指正。 一、上帝、永生与信仰1 上帝存在吗","text":"前言：首先，这是《Philosophical Dilemmas》第三版中译本《没有标准答案的哲学问题》的读书笔记（阅读理解/课后习题/这次语文月考又挂了哎），全书共五章，每章约7个问题，回答包含两到三个立场，都是根本性的问题，难以回答，但还是试着做出选择并给出自己的理由，必然存在前后矛盾，尽力逻辑自洽。全部大概分成五次发，欢迎讨论，求指正。 一、上帝、永生与信仰1 上帝存在吗 是：因果论有神论者 否定特性与否定特征近义，描述事物具有否定特性/征无法告诉我们事物具体究竟是如何的，只能排除事物具有某种特征的可能性，无法定义事物所需要被描述的特性。(例：不是树的植物) 不能，可以，因为思考不一定要有结果，人的想象能力也会变化。 不可以，因为想象和思考都是个人的行为，受限于个人的认知能力，若以现阶段社会主流的基本定义来说是不存在的(90°直角与圆边冲突) 不会，会 不能，事实一和事实二冲突 是：智慧有神论者 因为机器的各个部分一定是通过某种特定方式有计划地组合在一起，而不是随意地拼在一起。如果是机器，一定是由一个智能的设计师创造出来的，这个英明、具有力量的设计师只能是上帝。 机器不会偶然出现—&gt;机器有设计师 世界秩序井然—&gt;世界不是垃圾堆，更像一台机器，且比机器更复杂精确—&gt;世界不会偶然自己诞生—世界有设计师—设计师比我们更有能耐是上帝—上帝存在 不可以，因为他首先证明了世界具有机器的基本特征，证明了有”设计师”的存在，间接证明的是设计师比我们更强大更有智慧，即上帝。 世界与机器一样存在一定的因果关系。 因为没有一台机器是偶然产生的，如果世界是偶然产生的，是”进化”而来的，那我们会看到机器可以通过”进化”而自行长大。而且偶然结合的过程无法解释人类这样复杂的生物是如何形成的。 都会的 不：无神论者 原始部落到古希腊的进化 神灵都退到奥林匹斯处，而且数量大大减少 神的概念出现在神教中，他指导但不甘于历史，上帝减少以凡人形象式出现，人们需要劳驾上帝解释的东西变少，宗教信仰的根基动摇 是的，我认为 上帝概念变化方式 上帝的概念离人物事务更远，很少参与和干预人间的事务 不再相信人类的智慧是上帝本性的副本，不相信上帝会展现出嫉妒、愤怒和同情的特点 对人自己的形象从相信是上帝设计的人体和人脑转变为相信自然选择过程，就像其他物种一样没有人能给人类描绘一个原始的蓝图。对上帝的概念脱离人类的形象，即不再相信人类的智慧是上帝的副本 相信上帝同时相信与人类没有相同/把星系或热能称为上帝 我认为不可能，因为上帝的形象本就是基于比人类更全能的高等形象，即其本质上还是脱胎于人类，无法与人类的形象完全脱离关系 我认为不能，星系或热能都是物理学范畴的概念，上帝更多的是宗教概念，难以混为一谈 可能，因为本就没有理由相信上帝本善 1选择：无神论者 2 上帝像人一样吗不：抽象主义者 会。他是一个智慧慈祥的老人，白须长而密，沐浴在耀眼的白光中，手握权杖，身披锦袍。 不认为，我认为这取决于孩子个人的成长环境与成长经历。 与单纯的物理意义不同，上帝象征着一种形象，在每个人想象中不同的形象，这些形象有一些共通的特征，传达一些共通的精神。上帝这个概念更倾向于一个精神概念。 不能。如果是发自本心的爱，其指向本身并没有对错，而道德更多是人为的标准，本质上与爱并无直接关联。若男人真心爱女同事也当面对本心(与妻子的契约解除与否，忠诚背叛则是另一回事)，女人若真爱她的工作追求目标也无可厚非，爱指导他们的追逐。 一般来说需要研究构造，即事物AB组成成分是否相同，组成结构是否相同。外在需要证明闪电与电具有相同的特征、性质，内在证明两者由同样物质构成。 上帝未必与我们同在，针对文中提到的，母亲可能抛弃孩子，厨房里的工作者可能因为恶念下毒，病房中的护士也可能毫无耐心。被抛弃的孩子、被毒死的客人、得不到护理的患者有理由相信上帝和爱都不与他们同在。 人们实现了愿望会相信上帝能听到他们的祈祷，但更多的人更多的愿望不会被实现。 是：人格主义者 一种生理假设：人们努力实现自我意识，把自己投射到环境之中然后读到投射结果，以此来认识自我。 因为他认为宗教会阻止人们充分挖掘自己的潜能。 因为他们希望上帝存在。 (对多神教缺乏了解只好口胡了) 粗略的来看可能适合，以北欧神话体系为例，其本身还是父权体系，而此处提到的佛洛依德理论核心是父亲形象，因此也许合适？ 鬼知道那是什么东西 因为上帝存在与否与普遍认同的上帝形象之间并没有必然联系，有可能人类确实将自身形象投射到上帝形象上而存在的上帝确实也是人的形象，投射论本身不涉及客观的论据，本身并不证明什么。 不知道。 本文认为相信事物的存在只是因为只是因为希望它存在是非理性的。并不认为是非理性的，人格主义者认为无法充分证明信奉上帝是非理性的。 1选择：人格主义者 3 上帝允许无辜的苦难吗反对者 人为恶与自然恶 上帝想消除恶也能消除恶 两个对立面是：①上帝是全能而仁慈的，他爱它所创造的一切，如果这样，怎么会发生这么多恶?②不能消除恶的存在不是全能的，不想消除恶的存在不是仁慈的，因此就不是上帝了 因为综合上帝的两个重要特征，如果上帝存在必然不会有恶发生，而实际上因为有恶的发生，就没有一种仁慈而全能的事物。 首先除了人类造的恶外还有其他的恶不归人类负责。例如地震带来巨大灾难，但与自由意志无关；其次如果是人类恶，上帝如果全知，在创造时就能预料到给人类自由，人类会在世界上作恶，但它还是创造了我们，上帝该为这后果负责。 他会要人们为了天堂中的幸福忍辱负重，承受现实生活的苦难。是的，因为不然无法理解承受恶的我们便无法信仰上帝。 调和者 这个世界没被消除的苦难与上帝全知仁慈形象之间的冲突 本文认为人需要经历长时间的艰苦磨难才能形成真正的品德，品德是人生经历的产物。个人认为此文并没有正面解答这个问题 这个错误是他们抱怨这个世界的痛苦和苦难，似乎他们能把这些苦难都消除掉，他们只看到了事情的表面，没看出痛苦是生活必不可少的一部分 不赞同，个人而言更愿意生活在现在这个世界，可是每个人最适合的世界并不一样。不是所有人都该面对所谓苦难的机会，而且苦难并不是一种给所有人机会的东西，天灾一类的苦难比起给人机会更多的是直接剥夺了人的生命或选择的机会，剥夺了一些人的创意和力量。林肯的人性散发着光辉，但被疾病夺去性命的是他的小儿子而不是他，战争死去的是他的国民也不是他。 是指苦难即人性的考验，考验人的品德、对上帝的忠诚一类的存在。有区别，考验说假定上帝多疑残忍，假定接受考验前人就已经有了品德这一特性，调和者说否定两者；调和者还认为痛苦只是一个机会，一种可能性，而非具有测验性质的、更多是被刻意制造的考验这种存在。 不认为，不相容。 1选择：反对者 4 灵魂是不朽的吗不：死亡论者 因为他们认为可以想象死后这个世界的样子，想象人群、季节、变化、日常活动，在脑海里描绘这些情景就像看着它们发生。然而事实是人没有肉体就没有五官、感觉，从想象上看与世界不会有任何互动 因为他的肉体被埋葬，而没有肉体也就没有感觉，无法与世界产生互动 同意，基于世上大多数人都认同自己肉体性别这一认知基础。不同性别社会对他们有不同的要求和期待，因此进一步影响个性的形成。 死亡论者认为人们能够想象没有肉体的存在，进而想象与自己无关的继续运转的世界，即你受限于肉体，与世界间无互动，而无互动即没有真正待在这个世界里 不能证明，薛定谔的猫定律，我想象不出两种状态共存于一个盒子且在盒子打开的那一瞬间决定最终状态 没有 是：存活论者 他们的一依据是历史上有很多人声称他们看到钢丝去的鬼影或曾与死人堆话等，我认为基本理性，因为若是真的则是基于证据报告的看法，当然前提是报告足够可靠 全面彻底的检测他们的生平，排除一切预先了解或推断出结果的可能性，确定相关情报只有死人才掌握 因为无法解释病人为什么知道其他房间发生的事情 我认为理论上第二种最可信（在极其彻底的排查手段被应用的前提条件下） 按照此文观点，反对”死后生命说”的证据是肉体影响大脑的，而有证据表明大脑也可以影响肉体，两者相互中和 不适用，因为反对观点证据有效的基础是该观点认为生命基于肉体，但支持”死后生命说”的观点并没有证明死后生命的基础与大脑有关，而且按照常规思路来看，大脑也可以是肉体的一部分，中和没有实际意义。 小想法A：1标题与论证内容有一定的差异？（如死后生命可以存在一段时间后再消逝？） ，灵魂存在但未必不朽等。 小想法B： 1这两篇的论证都有局限，存活论说服力不大，死亡论过于倾向于主观认知（即无法想象/未被认知的事物不存在） 小想法C： 1还有一个硬伤是先入为主的认为死后生命形式与生前别无二致，从而才得出结论认为无法与世界互动，但事实上若有死后生命，其形式应该是未知的（存活论中提到这点），获取信息的手段也是未知的 小想法D： 1例如以死后人以某种类似电磁波集合体的形式存在？电磁信号理论上能携带事务的所有信息（基于01信号的观点），但进一步猜测这种存在很快会消散，因此灵魂未必不朽 5 信仰是一个答案吗是：宗教信仰者 我们对世界和人类的了解甚少，免疫系统远比我们意识到的要复杂、微妙 用不同的方式思考死亡，科学研究后发现”没有人知道为什么会发生死亡”，必须面对肉体崩溃的局限，无法理解强烈求生意志的含义等。这使他变得谦卑，发现更多的局限性 死亡、起源、社会、感觉相关的终极问题。我不认为，我认为有人能理解而不为我们所知，或人类只是还没到那个阶段。 不同意 作者本身直言不需要论据和论证，只是因为自己想相信，即不接受反驳的意思，某种程度上是对的，对个体而言信仰确实可以不接受反驳，谈不上对错，但无法使他人信服，而如果试图讨论一些”共同”的东西，使人信服是有必要的 他不认为，他只是寻求一个能解答所有这些问题的回答，这个信念为所有其他问题提供了答案 不应该。也不应该，治疗方式无论如何应当有一定的理论实践基础 不：宗教质疑者 信仰可以是一种相对可能性的合理推论，如果有事实和客观依据。说某种信仰有证据就等于是说有些公认的事实可以让这种信仰更为可信，比如服用某种药物的十个病人中有九人的病治愈了，而没服药的没治愈，就表明这种药可能对类似的病更容易痊愈，这是证据。 一是因为被权威人士要求去信奉的，二是因为这会让人们感觉好受一些。 人们会永远学不会独立思考，而习惯了相信权威这种思维方式后人们也会在其他领域使用这种思维方式。 我认为不会，首先我没有信奉的宗教，而且相信权威人物也是建立在自行思考和对权威人物的观点思考后的结果，错了也只会指责相信错误的自己而非错误的权威。不能，科学权威的观点也需要经过我们个人的思考、逻辑判断和论证。 在关于种族和性别的优势上研究结果不明确时，我们会因为某个信念能让我们感到非常舒服而去相信他，这偏见本身就是严重的歧视。 主要分歧在持有信仰的理由上，信仰者认为不需要证据，而质疑者认为这样一厢情愿的依据信仰形式不对，应当有证据支撑。质疑者应当不会。 1选择：宗教质疑者 6 想要过有意义的生活，必须信仰上帝吗？意义型有神论者(生活的意义是服从上帝) 一个人不能自己决定某些价值让人生有意义，如同一个人不能让一个词语只对他一个人有意义。一个人不能创造个人私有的语言，也不能创造我们自己私有的价值观。 因为他认为一个人所追求的人生目标应该是有价值的，而不是随便什么目标都可以。这个人的人生与有个”有意义人生”的概念不相符，像这种微不足道的目标没有价值。我同意。 能，能。 因为他们无法正常的认识现实世界，他们的人生没有致力于有客观价值的某件事情，而是基于自己的幻想。论者认为幸福必须基于现实，他们并没有基于现实，因此目标也不具有客观价值。 会，因为他认为所有宗教都同意神灵是善良的、智慧的、乐于助人的、公平的。 有的。 存在主义者 (终极意义的神话) 在学校学习可以达到一个水平，这个水平可以带来更好的工作，得到一个更好的工作，得到一个更好的工作是有意义的。但海边度假不会导向任何目的，只是娱乐，不能导向就没有意义。 论者认为这和躺在海边的沙滩上一样是没有意义的。 我们很难了解上帝的规则，即使了解，也很难遵从。 有，有，能。滑雪者的意义很简单，假如他十年如一日的滑雪打破了某项滑雪世界纪录，想必就不会有人质疑其意义了，而且感受刺激，挑战人类极限本身也属于公认有意义的事情。 本质上是因为他以自己对生活方式的标准来定义幸福与最好，他们俩的行为都不符合他的价值观。 是的，呼吸吃饭不是我最终的人生目标。是我有意识自觉作出的选择。 1选择：存在主义者 7 佛教是一种哲学吗是：佛教徒 相信，可能，因为肉体的变化确实不受我们大脑思想直接控制(不能我希望身体健康就健康，只能间接通过饮食运动等来控制)。 因为人性欲望与现实固有本质之间产生了冲突 不。佛教不鼓励人们服从权威或信仰，当然也不鼓励人们信奉什么，而觉悟来自一个人自己的努力，不是来自信仰、恩赐或权威。 不是，我认为信仰神灵确实是基本条件。 觉悟要求理解自己和世界，理解后改变自己的情感行为，某种意义上可以说是自己对自己的拯救，而宗教概念的救赎多是指神灵对死后生命的拯救。获得救赎的主要障碍是原罪和作恶，而觉悟的主要阻力是无知和错觉。 因为更重要的是要理解基本事实，而不是担心无关紧要的细节。 不：专家 宗教和哲学相似的方式 都关心上帝、神灵和信仰等有关的问题，都思考肉体与大脑之间的关系、对与错、最好的生活方式、信仰及信仰的理由等问题 对一些思想著作都非常认真的研读，彼此的组织都接纳有相同思想的人分享彼此的观点 区别在态度上，宗教笃信、依靠崇拜和赞美，始于敬畏、爱、谦卑和恐惧等强烈情感，而哲学建立在批判基础上，要求怀疑、质疑和慎思，注重尽可能清晰地思考与论证，不为个人感情所左右 有的，第一点最重要，是其他三点的根基 没有，仅提供了证明各点内容的例证 不会，因为对宗教本质的认识需要长时间的研究、了解和渗透，几次活动远远不够，且无神论群众不会轻易拥有被弃置多年的信仰 我同意，因为人可以在面对不同事物时用不同的态度，对此人可以意识到两者的区别并有意识分开对待，再者人的思考中本身内在冲突就不少（所谓双重标准） 1选择：不是","categories":[{"name":"reading","slug":"reading","permalink":"http://blog.garenfeather.cn/categories/reading/"}],"tags":[{"name":"Philosophical Dilemmas","slug":"Philosophical-Dilemmas","permalink":"http://blog.garenfeather.cn/tags/Philosophical-Dilemmas/"},{"name":"philosophy","slug":"philosophy","permalink":"http://blog.garenfeather.cn/tags/philosophy/"}]},{"title":"简单随意的几种编程语言正则支持比较","slug":"简单随意的几种编程语言正则支持比较","date":"2015-01-16T09:52:17.000Z","updated":"2018-01-16T14:32:22.648Z","comments":true,"path":"2015/01/16/简单随意的几种编程语言正则支持比较/","link":"","permalink":"http://blog.garenfeather.cn/2015/01/16/简单随意的几种编程语言正则支持比较/","excerpt":"那会用各种语言都写过正则匹配，随便乱比较了一下，比较语言包括python、C#和java，没什么逻辑，想到啥看到啥就写的啥，仅供参考 一、版本 java8 C# 版本差异不大吧，不记得了 python 2.7 二、比较对应函数 python 的re模块中，search和match对应其他两种语言的match函数，确切的来说是search函数对应 python的match函数必须从字符串的第0位开始匹配一次，不存在则返回none（不明白这个函数究竟有什么用，正则表达式有自己的^符号来表示从头开始的匹配啊……）","text":"那会用各种语言都写过正则匹配，随便乱比较了一下，比较语言包括python、C#和java，没什么逻辑，想到啥看到啥就写的啥，仅供参考 一、版本 java8 C# 版本差异不大吧，不记得了 python 2.7 二、比较对应函数 python 的re模块中，search和match对应其他两种语言的match函数，确切的来说是search函数对应 python的match函数必须从字符串的第0位开始匹配一次，不存在则返回none（不明白这个函数究竟有什么用，正则表达式有自己的^符号来表示从头开始的匹配啊……） findall函数则对应所谓matches的功能，java中并没有什么matches，只能通过Matcher对象的match()方法不断搜索下去达到相对的效果，C#的matches函数会返回一个MatchCollection匹配结果集合对象（java这个正则支持差评） C#的Match对象通过match方法匹配、success属性返回成功与否的结果，匹配位置不会自行移动，要手动设定下一次匹配的offset（辅助参数有index和length来确定匹配位置），java的Matcher对象所用的find方法进行了匹配的同时返回匹配成功与否的结果（一顶C#俩），有start和end方法返回匹配位置，并且会自行随着匹配而移动下一次匹配开始的位置 操作方式（包括compile、match、find等） python中用到的几种都是函数（type()结果为function），java有Pattern对象而C#有Regex对象，java有Matcher对象而C#有Match对象，java一般是用Pattern类的静态方法编译获得该对象，C#则通过以字符串为参数传统新建对象方式获得（new Pattern(str)）。两者的match（Matcher）对象都通过Pattern对象获得，而python则是将Pattern对象作为参数一起放入search（或者findall、match等等）方法中 功能完善 python对正则替换支持的最好，sub函数允许自行构建一个函数来对正则匹配的结果进行复杂的操作（这种操作方式的占了python本身“函数也可以是对象”的构建方式的优势），其他两种目测只能强行命名分组替换，需要更多的自行检测匹配结果 其他 默认情况下python、java和C#的.符号都不支持匹配\\n换行符，java和C#还不支持\\r，C#似乎在一堆字符串里匹配到\\r会出现迷之bug……（应该不是bug，还得多看doc） java里面\\r和\\n都视为line terminator，遇到会终止匹配，而C#和python不视\\r为line terminator，但是C#输出时作为回到行首符覆盖输出，通过输出我们看到的结果会不一样，而实际上其匹配结果跟python是一样的 三、后言 ……写的乱七八糟，将来怕是自己都看不懂 没准为了看得懂回头复习会有新的收获呢","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.garenfeather.cn/tags/python/"},{"name":"c#","slug":"c","permalink":"http://blog.garenfeather.cn/tags/c/"},{"name":"java","slug":"java","permalink":"http://blog.garenfeather.cn/tags/java/"}]}]}