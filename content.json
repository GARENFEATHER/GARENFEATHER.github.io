{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://blog.garenfeather.cn"},"pages":[{"title":"About","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"about/index.html","permalink":"http://blog.garenfeather.cn/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"categories/index.html","permalink":"http://blog.garenfeather.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"tags/index.html","permalink":"http://blog.garenfeather.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker添加iptables防火墙规则构建容器间通信","slug":"Docker添加iptables防火墙规则构建容器间通信","date":"2018-01-14T21:43:04.000Z","updated":"2018-01-15T00:20:20.825Z","comments":true,"path":"2018/01/15/Docker添加iptables防火墙规则构建容器间通信/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/15/Docker添加iptables防火墙规则构建容器间通信/","excerpt":"一、坑从何来最近正好看到解析Docker单主机网络的部分，提到通过link链接容器，于是深入思考了下link的机制，首先如果为容器添加一条链接会发生以下几件事： 描述目标容器的环境变量会被创建 链接的别名和对应目标容器的ip地址会被添加到DNS覆盖列表中 如果跨容器通信被禁止，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。 重点在于第三点，这里Docker添加的防火墙规则是允许两个容器通信到什么地步呢，大概有以下三种猜想： 两个容器间任意端口自由通信，应该不太可能，达到这种地步接近Joined容器共用同一个网络栈的级别了 容器任意端口都能连上目标容器EXPOSE的端口 容器只有指定的的进程（如pid唯一）、指定的端口号能够连上目标容器EXPOSE的端口，至于这个指定的进程和端口号猜测是在构建的时候指定好并添加到配置中去的？","text":"一、坑从何来最近正好看到解析Docker单主机网络的部分，提到通过link链接容器，于是深入思考了下link的机制，首先如果为容器添加一条链接会发生以下几件事： 描述目标容器的环境变量会被创建 链接的别名和对应目标容器的ip地址会被添加到DNS覆盖列表中 如果跨容器通信被禁止，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。 重点在于第三点，这里Docker添加的防火墙规则是允许两个容器通信到什么地步呢，大概有以下三种猜想： 两个容器间任意端口自由通信，应该不太可能，达到这种地步接近Joined容器共用同一个网络栈的级别了 容器任意端口都能连上目标容器EXPOSE的端口 容器只有指定的的进程（如pid唯一）、指定的端口号能够连上目标容器EXPOSE的端口，至于这个指定的进程和端口号猜测是在构建的时候指定好并添加到配置中去的？ 最初的猜想是3，因为如果是2的话，容器被非法入侵岂不是可以新开个进程随意连上数据库往外倒数据？（后来仔细想想，容器都被入侵了，跟权限被提到root了有啥区别……当然是为所欲为啊，不过当时没想清楚就是了）这明显不安全。 这里验证最直观可靠的方式还是看iptables的路由规则，开始实验。 二、在踩坑的边缘试探1.实验环境 Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-63-generic x86_64) Docker version 17.05.0-ce, build 89658be 2.iptables设置查看当前iptables设置： 1$ iptables -nL 以防万一大家可以先清洗一遍iptables，有配置的同学记得提前备份： 1$ iptables -F 清洗后： 12345678910Chain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy DROP)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destinationChain DOCKER (0 references)target prot opt source destinationChain DOCKER-ISOLATION (0 references)target prot opt source destination 3.icc、iptables选项与/etc/default/dockericc是跨容器通信开关，iptables则是Docker是否应用防火墙规则的开关，于是修改/etc/default/docker文件，禁止跨容器通信，要求Docker使用iptables规则： 1DOCKER_OPTS=&quot;--icc=false --iptables=true&quot; 同时去掉注释，并重启docker服务： 1$ service docker restart 再次查看当前iptables配置，可以看到docker和docker-isolation都被加入到了chain-forward项中： 1234567891011121314Chain FORWARD (policy DROP)target prot opt source destination DOCKER-ISOLATION all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 ctstate RELATED,ESTABLISHEDDOCKER all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 DROP all -- 0.0.0.0/0 0.0.0.0/0 Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:3306ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:3306Chain DOCKER-ISOLATION (1 references)target prot opt source destination RETURN all -- 0.0.0.0/0 0.0.0.0/0 此处用本机现有的mysql和redis做实验，redis依赖mysql（mysql密码请自行根据自己的配置修改）： 1$ docker run --rm --name mysql -e 3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 1$ docker run --rm --name redis --link mysql:mysql -d redis 操作完docker ps可以看到两个容器正常运行，但并没有看到iptables有新添加规则。 4.docker network之前的项目没有涉及到多网络配置，因此对network一无所知，加上无脑瞎找资料没思考清楚，误以为是两个容器不在一个网络内，于是查看默认bridge网络配置： 1$ docker network inspect bridge 部分相关配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;d14d164b2dbc43b33eb298d79e5928fda258129a02f6c2a7c310633a718d356c&quot;, &quot;Created&quot;: &quot;2018-01-15T03:53:42.133885625+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;Containers&quot;: &#123; &quot;5b81e33ddd5e7e79e6c315bd3889812362d19732e0ce9a0486edc98a26c59e77&quot;: &#123; &quot;Name&quot;: &quot;redis&quot;, &quot;EndpointID&quot;: &quot;df2e9dda0de35c4934a50d33bd23cb9d27301cac3882880ba58acf82713956f4&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;fada6a036ecba16bc1c08ec5b8fced59b51144a949d7c1051b78e88d7a4bb35f&quot;: &#123; &quot;Name&quot;: &quot;mysql&quot;, &quot;EndpointID&quot;: &quot;38a5036088b19daa08e212d947b44f3a94e823d9a2cd060d0fbfc19680591abf&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; &#125;, &quot;Labels&quot;: &#123;&#125;&#125; 发现两个容器都在默认网络里。顺便这里有个很迷的地方就是Options里的true和false都是字符串类型，但外面的却不是，后面会提到。观察配置发现icc选项还是true，说明刚才修改的/etc/default/docker文件很可能没起作用。此处有两个选择： 新建一个bridge网络，icc设为false 继续设法修改docker daemon启动选项 其实并没有选择，因为就参数来看只能设置icc，而iptables使用与否必须是docker daemon启动时设置好的。直接百度到的资料杂乱无章，对错参半，于是还是根据官网操作： 新建daemon.json： 1$ vim /etc/docker/daemon.json 输入以下内容 1234&#123; &quot;iptables&quot;: &quot;true&quot;, &quot;icc&quot;: &quot;false&quot;&#125; 并重启dockerd服务，发现会重启失败，显示： 1unable to configure the Docker daemon with file /etc/docker/daemon.json: json: cannot unmarshal string into Go value of type bool 这就是刚才提到的很迷的地方，欺负我们不懂go语言系列，参数改为以下内容： 1234&#123; &quot;iptables&quot;: true, &quot;icc&quot;: false&#125; 保存后再重启docker daemon，再次查看bridge网络，options选项中的com.docker.network.bridge.enable_icc应该为false了，说明配置生效了，此时再按上面步骤启动容器link，可以看到iptables多了两条规则： 1234Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:mysqlACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:mysql 操作成功，可以发现两个容器之间互联的是通过forward链的转发规则，具体规则可阅读iptables forward详解。外面替换一下两个容器的位置，也可以看到同样结果： 12$ docker run --rm --name redis -e 6379 -d redis$ docker run --rm --name mysql --link redis:redis -e MYSQL_ROOT_PASSWORD=123456 -d mysql 端口变成了redis的6379： 1234Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:6379ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:6379 5.结束验证过程中很多地方没想清楚胡乱操作一通，把原本简单的问题都搞复杂了，动手前深思熟虑还是很重要的啊（俗话说得好，真正写代码的时间能有20%不错了）。 二、后来1.仔细想想 其实当时还想顺着猜测3的思路深入思考过如果容器被非法入侵，直接攻击代码搞挂了原本的进程，用原本与目标容器3306连接的端口构建数据库的连接该怎么办……那当然是没办法啦啊哈哈哈，你说你家金库的钥匙密码人家都拿到了你的黄金怎么办，那当然是没办法的，重点应该在怎么防止密码和钥匙失窃上吧hhhhh。 而且退一步想，指定能与目标容器3306连接的端口可以办得到，但是绑定到进程上是没有实现的可能的，作为进程标识的pid是会被复用的，重启后pid会变，不可能每次重启进程都重新设定绑定关系，而且也没有设定的基础。 网络基础还是不扎实，很多东西没真正理解。 2.论如何查资料 珍爱生命，少查csdn，多看官方文档，过脑思考比无脑开车撞墙要好 努力改掉下意识避开英文的习惯 写操作指南不指明各种相关版本号的都是耍流氓 基础不牢，地动山摇，我还是太天真了.jpg","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.garenfeather.cn/tags/Docker/"},{"name":"network","slug":"network","permalink":"http://blog.garenfeather.cn/tags/network/"},{"name":"iptables","slug":"iptables","permalink":"http://blog.garenfeather.cn/tags/iptables/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-06-16T06:37:42.551Z","updated":"2017-06-16T06:37:42.551Z","comments":true,"path":"2017/06/16/hello-world/","link":"","permalink":"http://blog.garenfeather.cn/2017/06/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}