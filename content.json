{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://blog.garenfeather.cn"},"pages":[{"title":"About","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"about/index.html","permalink":"http://blog.garenfeather.cn/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"categories/index.html","permalink":"http://blog.garenfeather.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-16T06:56:04.768Z","updated":"2017-06-16T06:56:04.768Z","comments":true,"path":"tags/index.html","permalink":"http://blog.garenfeather.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker添加iptables防火墙规则构建容器间通信","slug":"Docker添加iptables防火墙规则构建容器间通信","date":"2018-01-14T21:43:04.000Z","updated":"2018-01-15T00:34:05.866Z","comments":true,"path":"2018/01/15/Docker添加iptables防火墙规则构建容器间通信/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/15/Docker添加iptables防火墙规则构建容器间通信/","excerpt":"一、坑从何来最近正好看到解析Docker单主机网络的部分，提到通过link链接容器，于是深入思考了下link的机制，首先如果为容器添加一条链接会发生以下几件事： 描述目标容器的环境变量会被创建 链接的别名和对应目标容器的ip地址会被添加到DNS覆盖列表中 如果跨容器通信被禁止，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。 重点在于第三点，这里Docker添加的防火墙规则是允许两个容器通信到什么地步呢，大概有以下三种猜想：","text":"一、坑从何来最近正好看到解析Docker单主机网络的部分，提到通过link链接容器，于是深入思考了下link的机制，首先如果为容器添加一条链接会发生以下几件事： 描述目标容器的环境变量会被创建 链接的别名和对应目标容器的ip地址会被添加到DNS覆盖列表中 如果跨容器通信被禁止，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。 重点在于第三点，这里Docker添加的防火墙规则是允许两个容器通信到什么地步呢，大概有以下三种猜想： 两个容器间任意端口自由通信，应该不太可能，达到这种地步接近Joined容器共用同一个网络栈的级别了 容器任意端口都能连上目标容器EXPOSE的端口 容器只有指定的的进程（如pid唯一）、指定的端口号能够连上目标容器EXPOSE的端口，至于这个指定的进程和端口号猜测是在构建的时候指定好并添加到配置中去的？ 最初的猜想是3，因为如果是2的话，容器被非法入侵岂不是可以新开个进程随意连上数据库往外倒数据？（后来仔细想想，容器都被入侵了，跟权限被提到root了有啥区别……当然是为所欲为啊，不过当时没想清楚就是了）这明显不安全。 这里验证最直观可靠的方式还是看iptables的路由规则，开始实验。 二、在踩坑的边缘试探1.实验环境 Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-63-generic x86_64) Docker version 17.05.0-ce, build 89658be 2.iptables设置查看当前iptables设置： 1$ iptables -nL 以防万一大家可以先清洗一遍iptables，有配置的同学记得提前备份： 1$ iptables -F 清洗后： 12345678910Chain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy DROP)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destinationChain DOCKER (0 references)target prot opt source destinationChain DOCKER-ISOLATION (0 references)target prot opt source destination 3.icc、iptables选项与/etc/default/dockericc是跨容器通信开关，iptables则是Docker是否应用防火墙规则的开关，于是修改/etc/default/docker文件，禁止跨容器通信，要求Docker使用iptables规则： 1DOCKER_OPTS=&quot;--icc=false --iptables=true&quot; 同时去掉注释，并重启docker服务： 1$ service docker restart 再次查看当前iptables配置，可以看到docker和docker-isolation都被加入到了chain-forward项中： 1234567891011121314Chain FORWARD (policy DROP)target prot opt source destination DOCKER-ISOLATION all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 ctstate RELATED,ESTABLISHEDDOCKER all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 DROP all -- 0.0.0.0/0 0.0.0.0/0 Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:3306ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:3306Chain DOCKER-ISOLATION (1 references)target prot opt source destination RETURN all -- 0.0.0.0/0 0.0.0.0/0 此处用本机现有的mysql和redis做实验，redis依赖mysql（mysql密码请自行根据自己的配置修改）： 1$ docker run --rm --name mysql -e 3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 1$ docker run --rm --name redis --link mysql:mysql -d redis 操作完docker ps可以看到两个容器正常运行，但并没有看到iptables有新添加规则。 4.docker network之前的项目没有涉及到多网络配置，因此对network一无所知，加上无脑瞎找资料没思考清楚，误以为是两个容器不在一个网络内，于是查看默认bridge网络配置： 1$ docker network inspect bridge 部分相关配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;d14d164b2dbc43b33eb298d79e5928fda258129a02f6c2a7c310633a718d356c&quot;, &quot;Created&quot;: &quot;2018-01-15T03:53:42.133885625+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;Containers&quot;: &#123; &quot;5b81e33ddd5e7e79e6c315bd3889812362d19732e0ce9a0486edc98a26c59e77&quot;: &#123; &quot;Name&quot;: &quot;redis&quot;, &quot;EndpointID&quot;: &quot;df2e9dda0de35c4934a50d33bd23cb9d27301cac3882880ba58acf82713956f4&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;fada6a036ecba16bc1c08ec5b8fced59b51144a949d7c1051b78e88d7a4bb35f&quot;: &#123; &quot;Name&quot;: &quot;mysql&quot;, &quot;EndpointID&quot;: &quot;38a5036088b19daa08e212d947b44f3a94e823d9a2cd060d0fbfc19680591abf&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; &#125;, &quot;Labels&quot;: &#123;&#125;&#125; 发现两个容器都在默认网络里。顺便这里有个很迷的地方就是Options里的true和false都是字符串类型，但外面的却不是，后面会提到。观察配置发现icc选项还是true，说明刚才修改的/etc/default/docker文件很可能没起作用。此处有两个选择： 新建一个bridge网络，icc设为false 继续设法修改docker daemon启动选项 其实并没有选择，因为就参数来看只能设置icc，而iptables使用与否必须是docker daemon启动时设置好的。直接百度到的资料杂乱无章，对错参半，于是还是根据官网操作： 新建daemon.json： 1$ vim /etc/docker/daemon.json 输入以下内容 1234&#123; &quot;iptables&quot;: &quot;true&quot;, &quot;icc&quot;: &quot;false&quot;&#125; 并重启dockerd服务，发现会重启失败，显示： 1unable to configure the Docker daemon with file /etc/docker/daemon.json: json: cannot unmarshal string into Go value of type bool 这就是刚才提到的很迷的地方，欺负我们不懂go语言系列，参数改为以下内容： 1234&#123; &quot;iptables&quot;: true, &quot;icc&quot;: false&#125; 保存后再重启docker daemon，再次查看bridge网络，options选项中的com.docker.network.bridge.enable_icc应该为false了，说明配置生效了，此时再按上面步骤启动容器link，可以看到iptables多了两条规则： 1234Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:mysqlACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:mysql 操作成功，可以发现两个容器之间互联的是通过forward链的转发规则，具体规则可阅读iptables forward详解。外面替换一下两个容器的位置，也可以看到同样结果： 12$ docker run --rm --name redis -e 6379 -d redis$ docker run --rm --name mysql --link redis:redis -e MYSQL_ROOT_PASSWORD=123456 -d mysql 端口变成了redis的6379： 1234Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:6379ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:6379 5.结束验证过程中很多地方没想清楚胡乱操作一通，把原本简单的问题都搞复杂了，动手前深思熟虑还是很重要的啊（俗话说得好，真正写代码的时间能有20%不错了）。 二、后来1.仔细想想 其实当时还想顺着猜测3的思路深入思考过如果容器被非法入侵，直接攻击代码搞挂了原本的进程，用原本与目标容器3306连接的端口构建数据库的连接该怎么办……那当然是没办法啦啊哈哈哈，你说你家金库的钥匙密码人家都拿到了你的黄金怎么办，那当然是没办法的，重点应该在怎么防止密码和钥匙失窃上吧hhhhh。 而且退一步想，指定能与目标容器3306连接的端口可以办得到，但是绑定到进程上是没有实现的可能的，作为进程标识的pid是会被复用的，重启后pid会变，不可能每次重启进程都重新设定绑定关系，而且也没有设定的基础。 网络基础还是不扎实，很多东西没真正理解。 2.论如何查资料 珍爱生命，少查csdn，多看官方文档，过脑思考比无脑开车撞墙要好 努力改掉下意识避开英文的习惯 写操作指南不指明各种相关版本号的都是耍流氓 基础不牢，地动山摇，我还是太天真了.jpg","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.garenfeather.cn/tags/Docker/"},{"name":"network","slug":"network","permalink":"http://blog.garenfeather.cn/tags/network/"},{"name":"iptables","slug":"iptables","permalink":"http://blog.garenfeather.cn/tags/iptables/"}]},{"title":"简单随意的几种编程语言正则支持比较","slug":"简单随意的几种编程语言正则支持比较","date":"2015-01-16T09:52:17.000Z","updated":"2018-01-16T09:55:03.363Z","comments":true,"path":"2015/01/16/简单随意的几种编程语言正则支持比较/","link":"","permalink":"http://blog.garenfeather.cn/2015/01/16/简单随意的几种编程语言正则支持比较/","excerpt":"","text":"那会用各种语言都写过正则匹配，随便乱比较了一下，比较语言包括python、C#和java，没什么逻辑，想到啥看到啥就写的啥，仅供参考 一、版本 java8 C# 版本差异不大吧，不记得了 python 2.7 二、比较对应函数 python 的re模块中，search和match对应其他两种语言的match函数，确切的来说是search函数对应 python的match函数必须从字符串的第0位开始匹配一次，不存在则返回none（不明白这个函数究竟有什么用，正则表达式有自己的^符号来表示从头开始的匹配啊……） findall函数则对应所谓matches的功能，java中并没有什么matches，只能通过Matcher对象的match()方法不断搜索下去达到相对的效果，C#的matches函数会返回一个MatchCollection匹配结果集合对象（java这个正则支持差评） C#的Match对象通过match方法匹配、success属性返回成功与否的结果，匹配位置不会自行移动，要手动设定下一次匹配的offset（辅助参数有index和length来确定匹配位置），java的Matcher对象所用的find方法进行了匹配的同时返回匹配成功与否的结果（一顶C#俩），有start和end方法返回匹配位置，并且会自行随着匹配而移动下一次匹配开始的位置 操作方式（包括compile、match、find等） python中用到的几种都是函数（type()结果为function），java有Pattern对象而C#有Regex对象，java有Matcher对象而C#有Match对象，java一般是用Pattern类的静态方法编译获得该对象，C#则通过以字符串为参数传统新建对象方式获得（new Pattern(str)）。两者的match（Matcher）对象都通过Pattern对象获得，而python则是将Pattern对象作为参数一起放入search（或者findall、match等等）方法中 功能完善 python对正则替换支持的最好，sub函数允许自行构建一个函数来对正则匹配的结果进行复杂的操作（这种操作方式的占了python本身“函数也可以是对象”的构建方式的优势），其他两种目测只能强行命名分组替换，需要更多的自行检测匹配结果 其他 默认情况下python、java和C#的.符号都不支持匹配\\n换行符，java和C#还不支持\\r，C#似乎在一堆字符串里匹配到\\r会出现迷之bug……（应该不是bug，还得多看doc） java里面\\r和\\n都视为line terminator，遇到会终止匹配，而C#和python不视\\r为line terminator，但是C#输出时作为回到行首符覆盖输出，通过输出我们看到的结果会不一样，而实际上其匹配结果跟python是一样的 后言 ……写的乱七八糟，将来怕是自己都看不懂 没准为了看得懂回头复习会有新的收获呢","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.garenfeather.cn/tags/python/"},{"name":"c#","slug":"c","permalink":"http://blog.garenfeather.cn/tags/c/"},{"name":"java","slug":"java","permalink":"http://blog.garenfeather.cn/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2015-01-15T06:22:27.000Z","updated":"2018-01-16T09:59:49.258Z","comments":true,"path":"2015/01/15/hello-world/","link":"","permalink":"http://blog.garenfeather.cn/2015/01/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}