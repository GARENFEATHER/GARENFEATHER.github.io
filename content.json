{"meta":{"title":"変わらないで","subtitle":"ダイスキでダイキライ","description":null,"author":"GarenFeather","url":"http://blog.garenfeather.cn"},"pages":[{"title":"About","date":"2017-06-16T06:56:04.769Z","updated":"2017-06-16T06:56:04.769Z","comments":true,"path":"about/index.html","permalink":"http://blog.garenfeather.cn/about/index.html","excerpt":"","text":""},{"title":"これで……分類ページ?","date":"2018-01-30T21:50:31.921Z","updated":"2018-01-30T21:50:31.919Z","comments":true,"path":"categories/index.html","permalink":"http://blog.garenfeather.cn/categories/index.html","excerpt":"","text":""},{"title":"大切なスケジュール","date":"2018-01-30T21:55:58.589Z","updated":"2018-01-30T21:55:58.588Z","comments":true,"path":"schedule/index.html","permalink":"http://blog.garenfeather.cn/schedule/index.html","excerpt":"","text":""},{"title":"これはラベルページ!","date":"2018-01-30T21:49:39.541Z","updated":"2018-01-30T21:49:39.540Z","comments":true,"path":"tags/index.html","permalink":"http://blog.garenfeather.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"my-mermaid-please","slug":"my-mermaid-please","date":"2018-03-07T13:43:22.000Z","updated":"2018-03-13T18:23:09.107Z","comments":true,"path":"2018/03/07/my-mermaid-please/","link":"","permalink":"http://blog.garenfeather.cn/2018/03/07/my-mermaid-please/","excerpt":"","text":".mermaid .label{font-family:trebuchet ms,verdana,arial;color:#333}.node circle,.node ellipse,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.node.clickable{cursor:pointer}.arrowheadPath{fill:green}.edgePath .path{stroke:green;stroke-width:1.5px}.edgeLabel{background-color:#e8e8e8}.cluster rect{fill:#cdffb2!important;rx:4!important;stroke:#6eaa49!important;stroke-width:1px!important}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{marker-end:\"url(#arrowhead)\"}.messageLine0,.messageLine1{stroke-width:1.5;stroke-dasharray:\"2 2\";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:\"2 2\";marker-end:\"url(#arrowhead)\";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:#d3d3d3;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:#d3d3d3;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}g.classGroup text{fill:#13540c;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:10px}g.classGroup rect{fill:#cde498;stroke:#13540c}g.classGroup line{stroke:#13540c;stroke-width:1}svg .classLabel .box{stroke:none;stroke-width:0;fill:#cde498;opacity:.5}svg .classLabel .label{fill:#13540c;font-size:10px}.relation{stroke:#13540c;stroke-width:1;fill:none}#compositionEnd,#compositionStart,.composition{fill:#13540c;stroke:#13540c;stroke-width:1}#aggregationEnd,#aggregationStart,.aggregation{fill:#cde498;stroke:#13540c;stroke-width:1}#dependencyEnd,#dependencyStart,#extensionEnd,#extensionStart{fill:#13540c;stroke:#13540c;stroke-width:1}.node text{font-size:14px}.node text,div.mermaidTooltip{font-family:trebuchet ms,verdana,arial}div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-size:12px;background:#cdffb2;border:1px solid #6eaa49;border-radius:2px;pointer-events:none;z-index:100} svg { color: rgb(0, 0, 0); font: normal normal 400 normal 16px / normal \"Times New Roman\"; } master, c651700c3084d1c53c258f26f54fnewbranch, 517f7ac5f92615","categories":[{"name":"test","slug":"test","permalink":"http://blog.garenfeather.cn/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://blog.garenfeather.cn/tags/test/"}]},{"title":"Ghost文档翻译——开发模式启动命令对比","slug":"Ghost文档翻译——开发模式启动命令对比","date":"2018-02-03T15:35:29.000Z","updated":"2018-02-03T16:55:43.249Z","comments":true,"path":"2018/02/03/Ghost文档翻译——开发模式启动命令对比/","link":"","permalink":"http://blog.garenfeather.cn/2018/02/03/Ghost文档翻译——开发模式启动命令对比/","excerpt":"原文：working-with-ghost 翻译部分： Day-to-day Development Commands Running Ghost 日常频繁使用的开发命令 运行Ghost Ghost有多种启动方式，每种都各有利弊，这些方式在默认条件下都会从http://localhost:2368./启动Ghost服务","text":"原文：working-with-ghost 翻译部分： Day-to-day Development Commands Running Ghost 日常频繁使用的开发命令 运行Ghost Ghost有多种启动方式，每种都各有利弊，这些方式在默认条件下都会从http://localhost:2368./启动Ghost服务 grunt dev 开发模式下最常见的Ghost启动方式 服务启动时编译构建client文件 监听server文件，有变化自动重启 监听client文件，文件变化时敏捷重建，变化包括文件的实时重载 grunt dev --server 启动时不编译client文件，也不监听其变化，其他与上一条命令 请确保client文件已编译，或者保证其内容为最新（见 grunt build） 在确保你不修改client文件的情况下这样有利于最小化启动时间，保存系统资源 grunt prod 生产模式下启动，启动时编译client文件 既不监听server文件也不监听client文件 相当于以npm start --production命令启动Ghost node index.js 单纯的启动Ghost服务器，不构建client，不监听文件变化也不自动重启服务 当你只想快速启动服务，且不介意手动修改文件要重启服务时适合此命令 不构建client文件 &amp; 可能会导致后台系统一片空白（见 grunt build） Written with StackEdit.","categories":[{"name":"translation","slug":"translation","permalink":"http://blog.garenfeather.cn/categories/translation/"}],"tags":[{"name":"ghost","slug":"ghost","permalink":"http://blog.garenfeather.cn/tags/ghost/"},{"name":"blog","slug":"blog","permalink":"http://blog.garenfeather.cn/tags/blog/"},{"name":"grunt","slug":"grunt","permalink":"http://blog.garenfeather.cn/tags/grunt/"},{"name":"npm","slug":"npm","permalink":"http://blog.garenfeather.cn/tags/npm/"},{"name":"node","slug":"node","permalink":"http://blog.garenfeather.cn/tags/node/"}]},{"title":"test","slug":"there-is-just-a-test","date":"2018-01-29T09:25:05.000Z","updated":"2018-01-30T17:41:56.125Z","comments":true,"path":"2018/01/29/there-is-just-a-test/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/29/there-is-just-a-test/","excerpt":"","text":".mermaid .label{font-family:trebuchet ms,verdana,arial;color:#333}.node circle,.node ellipse,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.node.clickable{cursor:pointer}.arrowheadPath{fill:green}.edgePath .path{stroke:green;stroke-width:1.5px}.edgeLabel{background-color:#e8e8e8}.cluster rect{fill:#cdffb2!important;rx:4!important;stroke:#6eaa49!important;stroke-width:1px!important}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{marker-end:\"url(#arrowhead)\"}.messageLine0,.messageLine1{stroke-width:1.5;stroke-dasharray:\"2 2\";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:\"2 2\";marker-end:\"url(#arrowhead)\";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:#d3d3d3;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:#d3d3d3;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}g.classGroup text{fill:#13540c;stroke:none;font-family:trebuchet ms,verdana,arial;font-size:10px}g.classGroup rect{fill:#cde498;stroke:#13540c}g.classGroup line{stroke:#13540c;stroke-width:1}svg .classLabel .box{stroke:none;stroke-width:0;fill:#cde498;opacity:.5}svg .classLabel .label{fill:#13540c;font-size:10px}.relation{stroke:#13540c;stroke-width:1;fill:none}#compositionEnd,#compositionStart,.composition{fill:#13540c;stroke:#13540c;stroke-width:1}#aggregationEnd,#aggregationStart,.aggregation{fill:#cde498;stroke:#13540c;stroke-width:1}#dependencyEnd,#dependencyStart,#extensionEnd,#extensionStart{fill:#13540c;stroke:#13540c;stroke-width:1}.node text{font-size:14px}.node text,div.mermaidTooltip{font-family:trebuchet ms,verdana,arial}div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-size:12px;background:#cdffb2;border:1px solid #6eaa49;border-radius:2px;pointer-events:none;z-index:100} svg { color: rgb(0, 0, 0); font: normal normal 400 normal 16px / normal \"Times New Roman\"; } AliceJohnHello John, how are you?Great!loop[ every day ]AliceJohn","categories":[],"tags":[]},{"title":"利用heroku实现免费的全平台科学上网","slug":"利用heroku实现免费的全平台科学上网","date":"2018-01-25T14:03:23.000Z","updated":"2018-01-25T14:56:34.722Z","comments":true,"path":"2018/01/25/利用heroku实现免费的全平台科学上网/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/25/利用heroku实现免费的全平台科学上网/","excerpt":"一、前言 思路来源 准备 一台连得上Google的服务器（测试用，可选） 这里用的是腾讯云买的CentOS 7.2，新加坡节点 一个heroku账号 heroku平台注册需要翻墙，但登录和部署均不需要 账号还有免费app余额 一台便宜且容易搞到手的国内服务器（可选） 仅作为中转服务器，不需要多平台共用可以不备 需要梯子服务的平台对应的客户端（Android、Win、Mac、Linux）","text":"一、前言 思路来源 准备 一台连得上Google的服务器（测试用，可选） 这里用的是腾讯云买的CentOS 7.2，新加坡节点 一个heroku账号 heroku平台注册需要翻墙，但登录和部署均不需要 账号还有免费app余额 一台便宜且容易搞到手的国内服务器（可选） 仅作为中转服务器，不需要多平台共用可以不备 需要梯子服务的平台对应的客户端（Android、Win、Mac、Linux） 内容较复杂，显示不全，完整内容请访问：https://www.zybuluo.com/RhineGaren/note/1031077","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"network","slug":"network","permalink":"http://blog.garenfeather.cn/tags/network/"},{"name":"heroku","slug":"heroku","permalink":"http://blog.garenfeather.cn/tags/heroku/"},{"name":"wall","slug":"wall","permalink":"http://blog.garenfeather.cn/tags/wall/"}]},{"title":"Docker添加iptables防火墙规则构建容器间通信","slug":"Docker添加iptables防火墙规则构建容器间通信","date":"2018-01-14T21:43:04.000Z","updated":"2018-01-16T14:37:47.210Z","comments":true,"path":"2018/01/15/Docker添加iptables防火墙规则构建容器间通信/","link":"","permalink":"http://blog.garenfeather.cn/2018/01/15/Docker添加iptables防火墙规则构建容器间通信/","excerpt":"一、坑从何来 最近正好看到解析Docker单主机网络的部分，提到通过link链接容器，于是深入思考了下link的机制，首先如果为容器添加一条链接会发生以下几件事： 描述目标容器的环境变量会被创建 链接的别名和对应目标容器的ip地址会被添加到DNS覆盖列表中 如果跨容器通信被禁止，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。 重点在于第三点，这里Docker添加的防火墙规则是允许两个容器通信到什么地步呢，大概有以下三种猜想：","text":"一、坑从何来 最近正好看到解析Docker单主机网络的部分，提到通过link链接容器，于是深入思考了下link的机制，首先如果为容器添加一条链接会发生以下几件事： 描述目标容器的环境变量会被创建 链接的别名和对应目标容器的ip地址会被添加到DNS覆盖列表中 如果跨容器通信被禁止，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。 重点在于第三点，这里Docker添加的防火墙规则是允许两个容器通信到什么地步呢，大概有以下三种猜想： 两个容器间任意端口自由通信，应该不太可能，达到这种地步接近Joined容器共用同一个网络栈的级别了 容器任意端口都能连上目标容器EXPOSE的端口 容器只有指定的的进程（如pid唯一）、指定的端口号能够连上目标容器EXPOSE的端口，至于这个指定的进程和端口号猜测是在构建的时候指定好并添加到配置中去的？ 最初的猜想是3，因为如果是2的话，容器被非法入侵岂不是可以新开个进程随意连上数据库往外倒数据？（后来仔细想想，容器都被入侵了，跟权限被提到root了有啥区别……当然是为所欲为啊，不过当时没想清楚就是了）这明显不安全。 这里验证最直观可靠的方式还是看iptables的路由规则，开始实验。 二、在踩坑的边缘试探 1.实验环境 Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-63-generic x86_64) Docker version 17.05.0-ce, build 89658be 2.iptables设置 查看当前iptables设置： 1$ iptables -nL 以防万一大家可以先清洗一遍iptables，有配置的同学记得提前备份： 1$ iptables -F 清洗后： 12345678910Chain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy DROP)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destinationChain DOCKER (0 references)target prot opt source destinationChain DOCKER-ISOLATION (0 references)target prot opt source destination 3.icc、iptables选项与/etc/default/docker icc是跨容器通信开关，iptables则是Docker是否应用防火墙规则的开关，于是修改/etc/default/docker文件，禁止跨容器通信，要求Docker使用iptables规则： 1DOCKER_OPTS=&quot;--icc=false --iptables=true&quot; 同时去掉注释，并重启docker服务： 1$ service docker restart 再次查看当前iptables配置，可以看到docker和docker-isolation都被加入到了chain-forward项中： 1234567891011121314Chain FORWARD (policy DROP)target prot opt source destination DOCKER-ISOLATION all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 ctstate RELATED,ESTABLISHEDDOCKER all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 DROP all -- 0.0.0.0/0 0.0.0.0/0 Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:3306ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:3306Chain DOCKER-ISOLATION (1 references)target prot opt source destination RETURN all -- 0.0.0.0/0 0.0.0.0/0 此处用本机现有的mysql和redis做实验，redis依赖mysql（mysql密码请自行根据自己的配置修改）： 1$ docker run --rm --name mysql -e 3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 1$ docker run --rm --name redis --link mysql:mysql -d redis 操作完docker ps可以看到两个容器正常运行，但并没有看到iptables有新添加规则。 4.docker network 之前的项目没有涉及到多网络配置，因此对network一无所知，加上无脑瞎找资料没思考清楚，误以为是两个容器不在一个网络内，于是查看默认bridge网络配置： 1$ docker network inspect bridge 部分相关配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;d14d164b2dbc43b33eb298d79e5928fda258129a02f6c2a7c310633a718d356c&quot;, &quot;Created&quot;: &quot;2018-01-15T03:53:42.133885625+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;Containers&quot;: &#123; &quot;5b81e33ddd5e7e79e6c315bd3889812362d19732e0ce9a0486edc98a26c59e77&quot;: &#123; &quot;Name&quot;: &quot;redis&quot;, &quot;EndpointID&quot;: &quot;df2e9dda0de35c4934a50d33bd23cb9d27301cac3882880ba58acf82713956f4&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;fada6a036ecba16bc1c08ec5b8fced59b51144a949d7c1051b78e88d7a4bb35f&quot;: &#123; &quot;Name&quot;: &quot;mysql&quot;, &quot;EndpointID&quot;: &quot;38a5036088b19daa08e212d947b44f3a94e823d9a2cd060d0fbfc19680591abf&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; &#125;, &quot;Labels&quot;: &#123;&#125;&#125; 发现两个容器都在默认网络里。顺便这里有个很迷的地方就是Options里的true和false都是字符串类型，但外面的却不是，后面会提到。观察配置发现icc选项还是true，说明刚才修改的/etc/default/docker文件很可能没起作用。此处有两个选择： 新建一个bridge网络，icc设为false 继续设法修改docker daemon启动选项 其实并没有选择，因为就参数来看只能设置icc，而iptables使用与否必须是docker daemon启动时设置好的。直接百度到的资料杂乱无章，对错参半，于是还是根据官网操作： 新建daemon.json： 1$ vim /etc/docker/daemon.json 输入以下内容 1234&#123; &quot;iptables&quot;: &quot;true&quot;, &quot;icc&quot;: &quot;false&quot;&#125; 并重启dockerd服务，发现会重启失败，显示： 1unable to configure the Docker daemon with file /etc/docker/daemon.json: json: cannot unmarshal string into Go value of type bool 这就是刚才提到的很迷的地方，欺负我们不懂go语言系列，参数改为以下内容： 1234&#123; &quot;iptables&quot;: true, &quot;icc&quot;: false&#125; 保存后再重启docker daemon，再次查看bridge网络，options选项中的com.docker.network.bridge.enable_icc应该为false了，说明配置生效了，此时再按上面步骤启动容器link，可以看到iptables多了两条规则： 1234Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:mysqlACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:mysql 操作成功，可以发现两个容器之间互联的是通过forward链的转发规则，具体规则可阅读iptables forward详解。 外面替换一下两个容器的位置，也可以看到同样结果： 12$ docker run --rm --name redis -e 6379 -d redis$ docker run --rm --name mysql --link redis:redis -e MYSQL_ROOT_PASSWORD=123456 -d mysql 端口变成了redis的6379： 1234Chain DOCKER (1 references)target prot opt source destination ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:6379ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:6379 5.结束 验证过程中很多地方没想清楚胡乱操作一通，把原本简单的问题都搞复杂了，动手前深思熟虑还是很重要的啊（俗话说得好，真正写代码的时间能有20%不错了）。 二、后来 1.仔细想想 其实当时还想顺着猜测3的思路深入思考过如果容器被非法入侵，直接攻击代码搞挂了原本的进程，用原本与目标容器3306连接的端口构建数据库的连接该怎么办……那当然是没办法啦啊哈哈哈，你说你家金库的钥匙密码人家都拿到了你的黄金怎么办，那当然是没办法的，重点应该在怎么防止密码和钥匙失窃上吧hhhhh。 而且退一步想，指定能与目标容器3306连接的端口可以办得到，但是绑定到进程上是没有实现的可能的，作为进程标识的pid是会被复用的，重启后pid会变，不可能每次重启进程都重新设定绑定关系，而且也没有设定的基础。 网络基础还是不扎实，很多东西没真正理解。 2.论如何查资料 珍爱生命，少查csdn，多看官方文档，过脑思考比无脑开车撞墙要好 努力改掉下意识避开英文的习惯 写操作指南不指明各种相关版本号的都是***耍流氓*** 基础不牢，地动山摇，我还是太天真了.jpg","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.garenfeather.cn/tags/Docker/"},{"name":"network","slug":"network","permalink":"http://blog.garenfeather.cn/tags/network/"},{"name":"iptables","slug":"iptables","permalink":"http://blog.garenfeather.cn/tags/iptables/"}]},{"title":"分布式锁机制及几种方案对比","slug":"分布式锁机制及几种方案对比","date":"2017-11-24T05:51:54.000Z","updated":"2018-02-03T16:56:10.956Z","comments":true,"path":"2017/11/24/分布式锁机制及几种方案对比/","link":"","permalink":"http://blog.garenfeather.cn/2017/11/24/分布式锁机制及几种方案对比/","excerpt":"原文：分布式锁那些事 本文是在原文基础上用自己的语言试着更简洁的转述一遍，类似提纲，加入自己的小理解，和少部分扩展思考，内容基本为原文 分布式锁机制及几种方案对比","text":"原文：分布式锁那些事 本文是在原文基础上用自己的语言试着更简洁的转述一遍，类似提纲，加入自己的小理解，和少部分扩展思考，内容基本为原文 分布式锁机制及几种方案对比 为什么需要分布式锁 保证同一方法同一时间只有一个线程执行 单机性能有限，服务由单体部署拆分成分布式部署 需要跨进程，跨机，跨数据中心一致性方案(单进程内各语言或自身有锁方案，或配合架构有特定的组件集成) 分布式锁要求 同一时刻一个方法只能有一个进程的一个线程执行 高可用 高性能 锁失效方案 支持阻塞锁，获取锁失败可以继续尝试获取 支持非阻塞锁，获取失败立刻返回 分布式锁的三种方案分析 数据库方案 操作 数据库建表，在方法名上创建唯一索引 在表中插入方法名，执行者等的一条数据，插入成功获取锁 优势 借助数据库，结构简单 不足 受限数据库性能(可能要求多机部署，主备复制，数据同步等) 没有锁失效方案 不可重入 没有阻塞锁方案，需要自行循环 Redis方案 操作(2.6.12版之前) setnx设置key-value expire设置过期时间 del释放 问题及对应解决方案 每一步的操作都要保证原子性，set完没来得及设expire会导致死锁(2.6.12版实现了将两个操作合并原子化操作) 分布式环境下，A获取锁后阻塞，锁过期被B获取，A恢复后执行完错误释放了此时属于B的锁(经典CAS算法解决被误释放问题，但原本线程操作未完就失去锁的问题并没解决) 高可用要求主从复制机制，而主从复制多为异步，会出现数据不一致(不主从复制，用RedLock算法，该算法的成熟开源实现即Redisson，此处并不明白该算法如何解决主从复制的问题) 整体优势：借助Redis，实现方便 问题：超时作为锁失效机制不可靠，若处理时间过长会在完成前失去锁 Zookeeper方案 结构：内部分层文件系统目录树 操作 (原文有不清晰之处，待日后补充) 优点 高可用 可重入 阻塞锁 解决锁失效 缺点：频繁插入删除性能会比Redis差一些 其他 Redlock算法 大致思想为布置多个Redis Master节点，挨个申请锁，获取多数则成功，少数则在所有节点上解锁？ Written with StackEdit.","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"distributed","slug":"distributed","permalink":"http://blog.garenfeather.cn/tags/distributed/"},{"name":"lock","slug":"lock","permalink":"http://blog.garenfeather.cn/tags/lock/"},{"name":"redis","slug":"redis","permalink":"http://blog.garenfeather.cn/tags/redis/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://blog.garenfeather.cn/tags/zookeeper/"},{"name":"database","slug":"database","permalink":"http://blog.garenfeather.cn/tags/database/"}]},{"title":"【Philosophical Dilemmas】上帝、永生与信仰","slug":"【Philosophical-Dilemmas】上帝、永生与信仰","date":"2017-10-24T12:24:44.000Z","updated":"2018-01-31T12:28:43.712Z","comments":true,"path":"2017/10/24/【Philosophical-Dilemmas】上帝、永生与信仰/","link":"","permalink":"http://blog.garenfeather.cn/2017/10/24/【Philosophical-Dilemmas】上帝、永生与信仰/","excerpt":"前言：首先，这是《Philosophical Dilemmas》第三版中译本《没有标准答案的哲学问题》的读书笔记~~（阅读理解/课后习题/这次语文月考又挂了哎）~~，全书共五章，每章约7个问题，回答包含两到三个立场，都是根本性的问题，难以回答，但还是试着做出选择并给出自己的理由，必然存在前后矛盾，尽力逻辑自洽。全部大概分成五次发，欢迎讨论，求指正。 一、上帝、永生与信仰 1 上帝存在吗","text":"前言：首先，这是《Philosophical Dilemmas》第三版中译本《没有标准答案的哲学问题》的读书笔记~~（阅读理解/课后习题/这次语文月考又挂了哎）~~，全书共五章，每章约7个问题，回答包含两到三个立场，都是根本性的问题，难以回答，但还是试着做出选择并给出自己的理由，必然存在前后矛盾，尽力逻辑自洽。全部大概分成五次发，欢迎讨论，求指正。 一、上帝、永生与信仰 1 上帝存在吗 是：因果论有神论者 否定特性与否定特征近义，描述事物具有否定特性/征无法告诉我们事物具体究竟是如何的，只能排除事物具有某种特征的可能性，无法定义事物所需要被描述的特性。(例：不是树的植物) 不能，可以，因为思考不一定要有结果，人的想象能力也会变化。 不可以，因为想象和思考都是个人的行为，受限于个人的认知能力，若以现阶段社会主流的基本定义来说是不存在的(90°直角与圆边冲突) 不会，会 不能，事实一和事实二冲突 是：智慧有神论者 因为机器的各个部分一定是通过某种特定方式有计划地组合在一起，而不是随意地拼在一起。如果是机器，一定是由一个智能的设计师创造出来的，这个英明、具有力量的设计师只能是上帝。 机器不会偶然出现—&gt;机器有设计师 世界秩序井然—&gt;世界不是垃圾堆，更像一台机器，且比机器更复杂精确—&gt;世界不会偶然自己诞生—世界有设计师—设计师比我们更有能耐是上帝—上帝存在 不可以，因为他首先证明了世界具有机器的基本特征，证明了有&quot;设计师&quot;的存在，间接证明的是设计师比我们更强大更有智慧，即上帝。 世界与机器一样存在一定的因果关系。 因为没有一台机器是偶然产生的，如果世界是偶然产生的，是&quot;进化&quot;而来的，那我们会看到机器可以通过&quot;进化&quot;而自行长大。而且偶然结合的过程无法解释人类这样复杂的生物是如何形成的。 都会的 不：无神论者 原始部落到古希腊的进化 神灵都退到奥林匹斯处，而且数量大大减少 神的概念出现在神教中，他指导但不甘于历史，上帝减少以凡人形象式出现，人们需要劳驾上帝解释的东西变少，宗教信仰的根基动摇 是的，我认为 上帝概念变化方式 上帝的概念离人物事务更远，很少参与和干预人间的事务 不再相信人类的智慧是上帝本性的副本，不相信上帝会展现出嫉妒、愤怒和同情的特点 对人自己的形象从相信是上帝设计的人体和人脑转变为相信自然选择过程，就像其他物种一样没有人能给人类描绘一个原始的蓝图。对上帝的概念脱离人类的形象，即不再相信人类的智慧是上帝的副本 相信上帝同时相信与人类没有相同/把星系或热能称为上帝 我认为不可能，因为上帝的形象本就是基于比人类更全能的高等形象，即其本质上还是脱胎于人类，无法与人类的形象完全脱离关系 我认为不能，星系或热能都是物理学范畴的概念，上帝更多的是宗教概念，难以混为一谈 可能，因为本就没有理由相信上帝本善 1选择：无神论者 2 上帝像人一样吗 不：抽象主义者 会。他是一个智慧慈祥的老人，白须长而密，沐浴在耀眼的白光中，手握权杖，身披锦袍。 不认为，我认为这取决于孩子个人的成长环境与成长经历。 与单纯的物理意义不同，上帝象征着一种形象，在每个人想象中不同的形象，这些形象有一些共通的特征，传达一些共通的精神。上帝这个概念更倾向于一个精神概念。 不能。如果是发自本心的爱，其指向本身并没有对错，而道德更多是人为的标准，本质上与爱并无直接关联。若男人真心爱女同事也当面对本心(与妻子的契约解除与否，忠诚背叛则是另一回事)，女人若真爱她的工作追求目标也无可厚非，爱指导他们的追逐。 一般来说需要研究构造，即事物AB组成成分是否相同，组成结构是否相同。外在需要证明闪电与电具有相同的特征、性质，内在证明两者由同样物质构成。 上帝未必与我们同在，针对文中提到的，母亲可能抛弃孩子，厨房里的工作者可能因为恶念下毒，病房中的护士也可能毫无耐心。被抛弃的孩子、被毒死的客人、得不到护理的患者有理由相信上帝和爱都不与他们同在。 人们实现了愿望会相信上帝能听到他们的祈祷，但更多的人更多的愿望不会被实现。 是：人格主义者 一种生理假设：人们努力实现自我意识，把自己投射到环境之中然后读到投射结果，以此来认识自我。 因为他认为宗教会阻止人们充分挖掘自己的潜能。 因为他们希望上帝存在。 (对多神教缺乏了解只好口胡了) 粗略的来看可能适合，以北欧神话体系为例，其本身还是父权体系，而此处提到的佛洛依德理论核心是父亲形象，因此也许合适？ 鬼知道那是什么东西 因为上帝存在与否与普遍认同的上帝形象之间并没有必然联系，有可能人类确实将自身形象投射到上帝形象上而存在的上帝确实也是人的形象，投射论本身不涉及客观的论据，本身并不证明什么。 不知道。 本文认为相信事物的存在只是因为只是因为希望它存在是非理性的。并不认为是非理性的，人格主义者认为无法充分证明信奉上帝是非理性的。 1选择：人格主义者 3 上帝允许无辜的苦难吗 反对者 人为恶与自然恶 上帝想消除恶也能消除恶 两个对立面是：①上帝是全能而仁慈的，他爱它所创造的一切，如果这样，怎么会发生这么多恶?②不能消除恶的存在不是全能的，不想消除恶的存在不是仁慈的，因此就不是上帝了 因为综合上帝的两个重要特征，如果上帝存在必然不会有恶发生，而实际上因为有恶的发生，就没有一种仁慈而全能的事物。 首先除了人类造的恶外还有其他的恶不归人类负责。例如地震带来巨大灾难，但与自由意志无关；其次如果是人类恶，上帝如果全知，在创造时就能预料到给人类自由，人类会在世界上作恶，但它还是创造了我们，上帝该为这后果负责。 他会要人们为了天堂中的幸福忍辱负重，承受现实生活的苦难。是的，因为不然无法理解承受恶的我们便无法信仰上帝。 调和者 这个世界没被消除的苦难与上帝全知仁慈形象之间的冲突 本文认为人需要经历长时间的艰苦磨难才能形成真正的品德，品德是人生经历的产物。个人认为此文并没有正面解答这个问题 这个错误是他们抱怨这个世界的痛苦和苦难，似乎他们能把这些苦难都消除掉，他们只看到了事情的表面，没看出痛苦是生活必不可少的一部分 不赞同，个人而言更愿意生活在现在这个世界，可是每个人最适合的世界并不一样。不是所有人都该面对所谓苦难的机会，而且苦难并不是一种给所有人机会的东西，天灾一类的苦难比起给人机会更多的是直接剥夺了人的生命或选择的机会，剥夺了一些人的创意和力量。林肯的人性散发着光辉，但被疾病夺去性命的是他的小儿子而不是他，战争死去的是他的国民也不是他。 是指苦难即人性的考验，考验人的品德、对上帝的忠诚一类的存在。有区别，考验说假定上帝多疑残忍，假定接受考验前人就已经有了品德这一特性，调和者说否定两者；调和者还认为痛苦只是一个机会，一种可能性，而非具有测验性质的、更多是被刻意制造的考验这种存在。 不认为，不相容。 1选择：反对者 4 灵魂是不朽的吗 不：死亡论者 因为他们认为可以想象死后这个世界的样子，想象人群、季节、变化、日常活动，在脑海里描绘这些情景就像看着它们发生。然而事实是人没有肉体就没有五官、感觉，从想象上看与世界不会有任何互动 因为他的肉体被埋葬，而没有肉体也就没有感觉，无法与世界产生互动 同意，基于世上大多数人都认同自己肉体性别这一认知基础。不同性别社会对他们有不同的要求和期待，因此进一步影响个性的形成。 死亡论者认为人们能够想象没有肉体的存在，进而想象与自己无关的继续运转的世界，即你受限于肉体，与世界间无互动，而无互动即没有真正待在这个世界里 不能证明，薛定谔的猫定律，我想象不出两种状态共存于一个盒子且在盒子打开的那一瞬间决定最终状态 没有 是：存活论者 他们的一依据是历史上有很多人声称他们看到钢丝去的鬼影或曾与死人堆话等，我认为基本理性，因为若是真的则是基于证据报告的看法，当然前提是报告足够可靠 全面彻底的检测他们的生平，排除一切预先了解或推断出结果的可能性，确定相关情报只有死人才掌握 因为无法解释病人为什么知道其他房间发生的事情 我认为理论上第二种最可信（在极其彻底的排查手段被应用的前提条件下） 按照此文观点，反对&quot;死后生命说&quot;的证据是肉体影响大脑的，而有证据表明大脑也可以影响肉体，两者相互中和 不适用，因为反对观点证据有效的基础是该观点认为生命基于肉体，但支持&quot;死后生命说&quot;的观点并没有证明死后生命的基础与大脑有关，而且按照常规思路来看，大脑也可以是肉体的一部分，中和没有实际意义。 小想法A： 1标题与论证内容有一定的差异？（如死后生命可以存在一段时间后再消逝？） ，灵魂存在但未必不朽等。 小想法B： 1这两篇的论证都有局限，存活论说服力不大，死亡论过于倾向于主观认知（即无法想象/未被认知的事物不存在） 小想法C： 1还有一个硬伤是先入为主的认为死后生命形式与生前别无二致，从而才得出结论认为无法与世界互动，但事实上若有死后生命，其形式应该是未知的（存活论中提到这点），获取信息的手段也是未知的 小想法D： 1例如以死后人以某种类似电磁波集合体的形式存在？电磁信号理论上能携带事务的所有信息（基于01信号的观点），但进一步猜测这种存在很快会消散，因此灵魂未必不朽 5 信仰是一个答案吗 是：宗教信仰者 我们对世界和人类的了解甚少，免疫系统远比我们意识到的要复杂、微妙 用不同的方式思考死亡，科学研究后发现&quot;没有人知道为什么会发生死亡&quot;，必须面对肉体崩溃的局限，无法理解强烈求生意志的含义等。这使他变得谦卑，发现更多的局限性 死亡、起源、社会、感觉相关的终极问题。我不认为，我认为有人能理解而不为我们所知，或人类只是还没到那个阶段。 不同意 作者本身直言不需要论据和论证，只是因为自己想相信，即不接受反驳的意思，某种程度上是对的，对个体而言信仰确实可以不接受反驳，谈不上对错，但无法使他人信服，而如果试图讨论一些&quot;共同&quot;的东西，使人信服是有必要的 他不认为，他只是寻求一个能解答所有这些问题的回答，这个信念为所有其他问题提供了答案 不应该。也不应该，治疗方式无论如何应当有一定的理论实践基础 不：宗教质疑者 信仰可以是一种相对可能性的合理推论，如果有事实和客观依据。说某种信仰有证据就等于是说有些公认的事实可以让这种信仰更为可信，比如服用某种药物的十个病人中有九人的病治愈了，而没服药的没治愈，就表明这种药可能对类似的病更容易痊愈，这是证据。 一是因为被权威人士要求去信奉的，二是因为这会让人们感觉好受一些。 人们会永远学不会独立思考，而习惯了相信权威这种思维方式后人们也会在其他领域使用这种思维方式。 我认为不会，首先我没有信奉的宗教，而且相信权威人物也是建立在自行思考和对权威人物的观点思考后的结果，错了也只会指责相信错误的自己而非错误的权威。不能，科学权威的观点也需要经过我们个人的思考、逻辑判断和论证。 在关于种族和性别的优势上研究结果不明确时，我们会因为某个信念能让我们感到非常舒服而去相信他，这偏见本身就是严重的歧视。 主要分歧在持有信仰的理由上，信仰者认为不需要证据，而质疑者认为这样一厢情愿的依据信仰形式不对，应当有证据支撑。质疑者应当不会。 1选择：宗教质疑者 6 想要过有意义的生活，必须信仰上帝吗？ 意义型有神论者(生活的意义是服从上帝) 一个人不能自己决定某些价值让人生有意义，如同一个人不能让一个词语只对他一个人有意义。一个人不能创造个人私有的语言，也不能创造我们自己私有的价值观。 因为他认为一个人所追求的人生目标应该是有价值的，而不是随便什么目标都可以。这个人的人生与有个&quot;有意义人生&quot;的概念不相符，像这种微不足道的目标没有价值。我同意。 能，能。 因为他们无法正常的认识现实世界，他们的人生没有致力于有客观价值的某件事情，而是基于自己的幻想。论者认为幸福必须基于现实，他们并没有基于现实，因此目标也不具有客观价值。 会，因为他认为所有宗教都同意神灵是善良的、智慧的、乐于助人的、公平的。 有的。 存在主义者 (终极意义的神话) 在学校学习可以达到一个水平，这个水平可以带来更好的工作，得到一个更好的工作，得到一个更好的工作是有意义的。但海边度假不会导向任何目的，只是娱乐，不能导向就没有意义。 论者认为这和躺在海边的沙滩上一样是没有意义的。 我们很难了解上帝的规则，即使了解，也很难遵从。 有，有，能。滑雪者的意义很简单，假如他十年如一日的滑雪打破了某项滑雪世界纪录，想必就不会有人质疑其意义了，而且感受刺激，挑战人类极限本身也属于公认有意义的事情。 本质上是因为他以自己对生活方式的标准来定义幸福与最好，他们俩的行为都不符合他的价值观。 是的，呼吸吃饭不是我最终的人生目标。是我有意识自觉作出的选择。 1选择：存在主义者 7 佛教是一种哲学吗 是：佛教徒 相信，可能，因为肉体的变化确实不受我们大脑思想直接控制(不能我希望身体健康就健康，只能间接通过饮食运动等来控制)。 因为人性欲望与现实固有本质之间产生了冲突 不。佛教不鼓励人们服从权威或信仰，当然也不鼓励人们信奉什么，而觉悟来自一个人自己的努力，不是来自信仰、恩赐或权威。 不是，我认为信仰神灵确实是基本条件。 觉悟要求理解自己和世界，理解后改变自己的情感行为，某种意义上可以说是自己对自己的拯救，而宗教概念的救赎多是指神灵对死后生命的拯救。获得救赎的主要障碍是原罪和作恶，而觉悟的主要阻力是无知和错觉。 因为更重要的是要理解基本事实，而不是担心无关紧要的细节。 不：专家 宗教和哲学相似的方式 都关心上帝、神灵和信仰等有关的问题，都思考肉体与大脑之间的关系、对与错、最好的生活方式、信仰及信仰的理由等问题 对一些思想著作都非常认真的研读，彼此的组织都接纳有相同思想的人分享彼此的观点 区别在态度上，宗教笃信、依靠崇拜和赞美，始于敬畏、爱、谦卑和恐惧等强烈情感，而哲学建立在批判基础上，要求怀疑、质疑和慎思，注重尽可能清晰地思考与论证，不为个人感情所左右 有的，第一点最重要，是其他三点的根基 没有，仅提供了证明各点内容的例证 不会，因为对宗教本质的认识需要长时间的研究、了解和渗透，几次活动远远不够，且无神论群众不会轻易拥有被弃置多年的信仰 我同意，因为人可以在面对不同事物时用不同的态度，对此人可以意识到两者的区别并有意识分开对待，再者人的思考中本身内在冲突就不少（所谓双重标准） 1选择：不是","categories":[{"name":"reading","slug":"reading","permalink":"http://blog.garenfeather.cn/categories/reading/"}],"tags":[{"name":"Philosophical Dilemmas","slug":"Philosophical-Dilemmas","permalink":"http://blog.garenfeather.cn/tags/Philosophical-Dilemmas/"},{"name":"philosophy","slug":"philosophy","permalink":"http://blog.garenfeather.cn/tags/philosophy/"},{"name":"god","slug":"god","permalink":"http://blog.garenfeather.cn/tags/god/"},{"name":"life","slug":"life","permalink":"http://blog.garenfeather.cn/tags/life/"},{"name":"belief","slug":"belief","permalink":"http://blog.garenfeather.cn/tags/belief/"}]},{"title":"简单随意的几种编程语言正则支持比较","slug":"简单随意的几种编程语言正则支持比较","date":"2015-01-16T09:52:17.000Z","updated":"2018-01-16T14:32:22.649Z","comments":true,"path":"2015/01/16/简单随意的几种编程语言正则支持比较/","link":"","permalink":"http://blog.garenfeather.cn/2015/01/16/简单随意的几种编程语言正则支持比较/","excerpt":"那会用各种语言都写过正则匹配，随便乱比较了一下，比较语言包括python、C#和java，没什么逻辑，想到啥看到啥就写的啥，仅供参考 一、版本 java8 C# 版本差异不大吧，不记得了 python 2.7 二、比较 对应函数 python 的re模块中，search和match对应其他两种语言的match函数，确切的来说是search函数对应 python的match函数必须从字符串的第0位开始匹配一次，不存在则返回none（不明白这个函数究竟有什么用，正则表达式有自己的^符号来表示从头开始的匹配啊……）","text":"那会用各种语言都写过正则匹配，随便乱比较了一下，比较语言包括python、C#和java，没什么逻辑，想到啥看到啥就写的啥，仅供参考 一、版本 java8 C# 版本差异不大吧，不记得了 python 2.7 二、比较 对应函数 python 的re模块中，search和match对应其他两种语言的match函数，确切的来说是search函数对应 python的match函数必须从字符串的第0位开始匹配一次，不存在则返回none（不明白这个函数究竟有什么用，正则表达式有自己的^符号来表示从头开始的匹配啊……） findall函数则对应所谓matches的功能，java中并没有什么matches，只能通过Matcher对象的match()方法不断搜索下去达到相对的效果，C#的matches函数会返回一个MatchCollection匹配结果集合对象（java这个正则支持差评） C#的Match对象通过match方法匹配、success属性返回成功与否的结果，匹配位置不会自行移动，要手动设定下一次匹配的offset（辅助参数有index和length来确定匹配位置），java的Matcher对象所用的find方法进行了匹配的同时返回匹配成功与否的结果（一顶C#俩），有start和end方法返回匹配位置，并且会自行随着匹配而移动下一次匹配开始的位置 操作方式（包括compile、match、find等） python中用到的几种都是函数（type()结果为function），java有Pattern对象而C#有Regex对象，java有Matcher对象而C#有Match对象，java一般是用Pattern类的静态方法编译获得该对象，C#则通过以字符串为参数传统新建对象方式获得（new Pattern(str)）。两者的match（Matcher）对象都通过Pattern对象获得，而python则是将Pattern对象作为参数一起放入search（或者findall、match等等）方法中 功能完善 python对正则替换支持的最好，sub函数允许自行构建一个函数来对正则匹配的结果进行复杂的操作（这种操作方式的占了python本身“函数也可以是对象”的构建方式的优势），其他两种目测只能强行命名分组替换，需要更多的自行检测匹配结果 其他 默认情况下python、java和C#的.符号都不支持匹配\\n换行符，java和C#还不支持\\r，C#似乎在一堆字符串里匹配到\\r会出现迷之bug……（应该不是bug，还得多看doc） java里面\\r和\\n都视为line terminator，遇到会终止匹配，而C#和python不视\\r为line terminator，但是C#输出时作为回到行首符覆盖输出，通过输出我们看到的结果会不一样，而实际上其匹配结果跟python是一样的 三、后言 ……写的乱七八糟，将来怕是自己都看不懂 没准为了看得懂回头复习会有新的收获呢","categories":[{"name":"coding","slug":"coding","permalink":"http://blog.garenfeather.cn/categories/coding/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.garenfeather.cn/tags/python/"},{"name":"c#","slug":"c","permalink":"http://blog.garenfeather.cn/tags/c/"},{"name":"java","slug":"java","permalink":"http://blog.garenfeather.cn/tags/java/"}]}]}